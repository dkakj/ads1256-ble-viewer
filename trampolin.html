<!DOCTYPE html>
<html>
<head>
  <title>Trampolin sensor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: sans-serif; text-align: center; padding: 2em; }
    #actual { font-size: 2em; margin: 1em 0; }
    canvas { max-width: 600px; margin: 2em auto; }
    button { padding: 1em; font-size: 1em; }
  </style>
</head>
<body>
  <h1>Trampolinsensor</h1>
  <button onclick="connect()">Connect to Sensor</button>
  <div id="actual">Actual: -- kg</div>

  <canvas id="currentChart"></canvas>
  <canvas id="previousChart"></canvas>
<pre id="log" style="text-align:left; max-width:600px; margin:2em auto; background:#eee; padding:1em;"></pre>

  <script>
    const SERVICE_UUID = '12345678-1234-1234-1234-1234567890ab';
    const KG_UUID = 'feedfeed-1234-5678-1234-feedfeedfeed';
    const JSON_UUID = 'abcdefab-1234-5678-1234-abcdefabcdef';

    let currentChart, previousChart;
    function logToPage(message) {
      const logDiv = document.getElementById('log');
      logDiv.textContent += message + '\n';
    }
    async function connect() {
      try {
        const device = await navigator.bluetooth.requestDevice({
            filters: [{ services: [SERVICE_UUID] }]
          });

        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(SERVICE_UUID);
      
        const kgChar = await service.getCharacteristic(KG_UUID);
        const jsonChar = await service.getCharacteristic(JSON_UUID);
      
        await kgChar.startNotifications();
        await jsonChar.startNotifications();
      
        kgChar.addEventListener('characteristicvaluechanged', handleKg);
        jsonChar.addEventListener('characteristicvaluechanged', handleJson);
      
        setupCharts();
      } catch (error) {
        console.error(error);
        alert('Connection failed: ' + error);
      }
    }

   function handleKg(event) {

       
  const raw = new TextDecoder().decode(event.target.value);
   //  logToPage("received: " + raw);
  const kg = parseFloat(raw);
  if (!isNaN(kg)) {
    document.getElementById('actual').textContent = `Actual: ${kg.toFixed(3)} kg`;
  }
}


  function handleJson(event) {
  const raw = new TextDecoder().decode(event.target.value);
  logToPage("Raw JSON received: " + raw);

  try {
    const json = JSON.parse(raw);

    if (Array.isArray(json.current)) updateChart(currentChart, json.current);
    if (Array.isArray(json.previous)) updateChart(previousChart, json.previous);
  } catch (e) {
    logToPage("JSON parse error: " + e.message);
  }
}


    function setupCharts() {
        if (currentChart) currentChart.destroy();
        if (previousChart) previousChart.destroy();
      
        const ctx1 = document.getElementById('currentChart').getContext('2d');
        const ctx2 = document.getElementById('previousChart').getContext('2d');
      
        currentChart = new Chart(ctx1, {
          type: 'line',
          data: {
            labels: Array.from({ length: 100 }, (_, i) => i),
            datasets: [{
              label: 'Current',
              data: [],
              borderColor: 'blue',
              fill: false
            }]
          },
          options: { responsive: true, animation: false }
        });
      
        previousChart = new Chart(ctx2, {
          type: 'line',
          data: {
            labels: Array.from({ length: 100 }, (_, i) => i),
            datasets: [{
              label: 'Previous',
              data: [],
              borderColor: 'green',
              fill: false
            }]
          },
          options: { responsive: true, animation: false }
        });
      }


    function updateChart(chart, dataArray) {
      chart.data.datasets[0].data = dataArray;
      chart.update();
    }
  </script>
</body>
</html>
